# designModel
设计模式

单例模式：
    饿汉式 
    懒汉式
    
工厂模式：将对象的实例化交给工厂实现
   
   1.简单工厂模式：
    
    发送接口：       send
    mail发送实现类:  mailSend
    sms发送实现类:   smsSend
    发送信息工厂类：  持有各种对象
   2.抽象工厂模式：
    
    在简单工厂模式的基础上，将实例工厂抽象化
   3.jdbc工厂模型：
    
    客户端--数据操作工厂--jdbc接口--以下为实现
    1.db2
    2.mysql
    3.oracle
    4.sqlserver
   
   4.spring beanFactory等
   
观察者模式：- 发布订阅模式 

    目标对象 1
    观察者对象 n  被动等待目标通知
    真实目标对象：具体的目标对象-在目标改变后，通知多有观察者
    真实观察者：具体的观察者对象，实现更新的方法，使自身状态和目标状态一致
    
    六方面：
    1.目标与观察者关系 1-N N-1都可以 
    2.单向依赖
    3.命名建议
    4.触发通知的时机：完成状态维护后进行通知，先设置值后通知
    5.观察者模式调用顺序示意图：
        1.准备阶段：
            ·创建目标对象
            ·创建观察者对象
            ·向目标对象注册观察者对象
        2.运行阶段：
            ·1：改变目标对象的状态
            ·1.1：通知所有注册的观察者对象进行相应的处理
            ·1.2：回调目标对象，获取相应数据
    6.通知的顺序：观察者之间不能有依赖关系，互相独立
    7.类型：
        1.推模型：目标对象知道观察者要什么数据--按需定制
            目标对象主动向观察者推送目标的详细信息
            推送的信息通常是目标对象的全部或部分数据--等同于广播通信
        2.拉模型：与上相反，把所有信息传过去让观察者自行过滤
            目标对象再通知观察者的时候，传递少量信息
            若观察者需要更详细信息，则需要自己去目标对象中获取--拉数据
            此模型实现，一般会把目标对象自身通过update方法传递给观察对象
    8.java.util包下提供观察者模式：
        1.不需定义观察者和目标接口--jdk已提供
        2.具体目标里不需要维护观察者注册信息，java在Observable类里已经实现好了
        3.触发通知方式改变：调用setChanged -java提供更精确的触发控制提供的功能
        4.具体的观察者实现里，update支持推、拉模型，java定义是考虑好的
    9.观察者优缺点：
        1.实现了观察者和目标之间的抽象耦合
        2.实现动态联动
        3.支持广播通信
        ---
        1.可能引起无谓的操作：
    10.使用场景：
        ·触发联动--本质
        ·区别对待不同需求的观察者
    11.实例场景：
              