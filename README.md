# DesignModel23

### 1.代理模式

    1.代理：
              -代理服务器
              -代理经纪人
    2.代理模式：23个经典模式中的一种，又称委托模式
        -为目标对象提供了一个代理，这个代理可以控制对目标对象的访问
            ·外界不用直接访问目标对象，而是访问代理对象，由代理对象在调用目标对象
            ·代理对象中可以添加监控和审查处理
            ·计算机所有问题都可以添加中间层解决，但是会引起新的问题
    3.java代理：
        -1.代理模式和静态代理：
            1.java代理分类：
                -静态代理：
                    -代理对象持有目标对象的句柄
                    -所有调用目标对象的方法，都调用代理对象的方法
                    -对每个方法，需要静态编码-理解简单，但代码繁琐
                    -方法多的时候，针对没法方法都要进行前置处理，后置处理，显得麻烦，每增加一个方法都需要处理
                -动态代理
        -2.动态代理：对目标对象的方法每次被调用，进行动态拦截
            -持有目标对象的句柄
            -实现InvocationHandler接口
                ·实现invoke方法
                ·所有的代理对象方法调用，都会转发到invoke方法来
                ·invoke的形参method，就是指代理对象方法的调用
                ·在invoke内部，可以根据method，使用目标对象不同的方法来响应请求
            -代理对象：
                ·根据给定的接口，由Proxy类自动生成的对象
                ·类型com.sun.proxy.$Proxy0,继承自java.lang.reflect.Proxy
                ·通常和目标对象实现同样的接口（可另实现其他的接口）
                ·实现多个接口：
                    ·接口的排序很重要
                    ·当多个接口里面有方法同名，则默认一第一个接口的方法调用
            -总结：理解代理对象和代理处理器的区别，谨慎使用代理对象实现多个接口
        -3.AOP编程：面向切面编程 使用java的动态代理实现
            -分离代码的耦合（高内聚，低耦合）
            -业务逻辑变化，不需要修改源代码，不用重启
            -加快编程和测试速度
    4.动态代理：
        1.代理一个接口：D:\go-20191030\DesignModel23\src\main\java\pers\li\proxy\dynamicproxy
        2.代理多个接口：D:\go-20191030\DesignModel23\src\main\java\pers\li\proxy\dynamicproxy\multiple
            ·接口的排序很重要
            ·当多个接口里面有方法同名，则默认一第一个接口的方法调用
   
### 2.单例模式：
    
    1.特点：
        ·单例类仅有一个实例供其他对象使用
        ·单例类必须由自己创建这个唯一实例
    2.单例创建：
        ·构造方法私有化 - 防止外部new对象
        ·提供public static Singleton getInstance()方法 供其他对象获取单例的实例
    3.分类：
        ·饿汉式：类加载时实例化
        ·懒汉式：调用时实例化
    4.饿汉式和懒汉式比对：
        ·饿汉式：
            类加载时初始化，线程安全
             *      优点：没有加锁，执行效率会提高。
             *      缺点：类加载时就初始化，分配内存。
             *      基于 classloader 机制避免了多线程的同步问题，
        ·懒汉式：
            懒汉式线程不安全的两个问题主要来源于：
             *          1.创建多个对象    synchronized+双检锁处理
             *          2.指令重排        volatile
      
